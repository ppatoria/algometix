<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exploring false sharing scenarios when multiple threads modify adjacent variables, leading to performance degradation and cache inefficiencies."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://algometix.com/blog/cpu_cache/multicore-caching/false-sharing/partitioned_array_processing_and_false_sharing/"><meta property="og:site_name" content="Algometix"><meta property="og:title" content="Impact of Adjacent Array Indices Modification"><meta property="og:description" content="Exploring false sharing scenarios when multiple threads modify adjacent variables, leading to performance degradation and cache inefficiencies."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-06T23:30:00+00:00"><meta property="article:modified_time" content="2025-02-06T23:30:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Performance Optimization"><meta property="article:tag" content="Low-Latency Programming"><meta property="article:tag" content="Cache Optimization"><meta property="article:tag" content="Multi-Core Architecture"><meta property="article:tag" content="False Sharing"><title>Impact of Adjacent Array Indices Modification | Algometix</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://algometix.com/blog/cpu_cache/multicore-caching/false-sharing/partitioned_array_processing_and_false_sharing/><link rel=stylesheet href=/book.min.434035e7885c7f5d12818bd9f111cf1a0925c6fb78382667381c3d5eda3fb4f1.css integrity="sha256-Q0A154hcf10SgYvZ8RHPGgklxvt4OCZnOBw9Xto/tPE=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.a25bc5ab2697543c5bdda3aa980d691f1b1990393ccc13bfc90869dbf0c43b5b.js integrity="sha256-olvFqyaXVDxb3aOqmA1pHxsZkDk8zBO/yQhp2/DEO1s=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Algometix</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/blog/cpu_cache/>CPU Cache: Organization, Optimization and Challenges</a><ul><li><a href=/blog/cpu_cache/cache-optimization/>Cache Optimization Techniques</a><ul><li><a href=/blog/cpu_cache/cache-optimization/cache-optimization-focusing-on-data-alignment/>Data Alignment: Enhancing Contiguous Data Processing</a></li><li><a href=/blog/cpu_cache/cache-optimization/cache-optimization-through-prefetching/>Cache Prefetching: Enhancing Non-Contiguous Data Processing</a></li></ul></li><li><a href=/blog/cpu_cache/multicore-caching/>Multi-Core Caching Techniques</a><ul><li><a href=/blog/cpu_cache/multicore-caching/cache-hierarchy/>Cache Hierarchy and Sharing</a></li><li><a href=/blog/cpu_cache/multicore-caching/false-sharing/>False Sharing</a><ul><li><a href=/blog/cpu_cache/multicore-caching/false-sharing/false_sharing_adjacent_variables/>Impact of Adjacent Variable Modification</a></li><li><a href=/blog/cpu_cache/multicore-caching/false-sharing/partitioned_array_processing_and_false_sharing/ class=active>Impact of Adjacent Array Indices Modification</a></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Impact of Adjacent Array Indices Modification</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#scenario-impact-of-adjacent-element-modification-during-parallel-loop-processing><strong>Scenario: Impact of Adjacent Element Modification During Parallel Loop Processing</strong></a><ul><li><a href=#false-sharing-illustration><strong>False Sharing Illustration</strong></a></li><li><a href=#code-parallel-order-book-modification-illustrating-potential-false-sharing><strong>Code: Parallel Order Book Modification (Illustrating Potential False Sharing)</strong></a></li></ul></li><li><a href=#mitigation-strategies-for-false-sharing-ordered-by-potential-efficiency><strong>Mitigation Strategies for False Sharing (Ordered by Potential Efficiency)</strong></a><ul><li><a href=#1-soa-separate-arrays-optionally-grouped-in-a-struct>1. <strong>SoA: Separate Arrays (Optionally Grouped in a Struct)</strong></a></li><li><a href=#2-data-alignment-with-padding>2. <strong>Data Alignment with Padding</strong></a></li><li><a href=#3-partitioning-with-padding>3. <strong>Partitioning with Padding</strong></a></li><li><a href=#4-local-buffers-and-merging-results>4. <strong>Local Buffers and Merging Results</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=scenario-impact-of-adjacent-element-modification-during-parallel-loop-processing><strong>Scenario: Impact of Adjacent Element Modification During Parallel Loop Processing</strong>
<a class=anchor href=#scenario-impact-of-adjacent-element-modification-during-parallel-loop-processing>#</a></h2><ul><li>Threads process separate parts of an array. When adjacent array elements reside within the same cache line, modifications by different threads can lead to performance degradation.</li><li>This is because even though threads are working on logically distinct elements, cache line invalidation forces threads to reload data unnecessarily.</li></ul><h3 id=false-sharing-illustration><strong>False Sharing Illustration</strong>
<a class=anchor href=#false-sharing-illustration>#</a></h3><p><img src=/diagrams/false_sharing_adjacent_array_indices.png alt="False Sharing: Adjacent array indices share the same cache line"></p><h3 id=code-parallel-order-book-modification-illustrating-potential-false-sharing><strong>Code: Parallel Order Book Modification (Illustrating Potential False Sharing)</strong>
<a class=anchor href=#code-parallel-order-book-modification-illustrating-potential-false-sharing>#</a></h3><h4 id=introduction-to-order-books-and-price-level-orders>Introduction to Order Books and Price Level Orders
<a class=anchor href=#introduction-to-order-books-and-price-level-orders>#</a></h4><p>In financial markets, an <strong>order book</strong> aggregates buy and sell orders for an asset. Each order specifies:</p><ol><li><strong>Price</strong>: The price at which the order is placed.</li><li><strong>Volume</strong>: The amount of the asset to be bought or sold at that price.</li></ol><p>Orders are grouped by price level, representing the available buy and sell interest at different price points.</p><h4 id=code-breakdown>Code Breakdown
<a class=anchor href=#code-breakdown>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;atomic&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> NUM_THREADS <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>// Number of threads to use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Structure for an order book level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderBookLevel</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> price;    <span style=color:#75715e>// Price of the order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> volume;   <span style=color:#75715e>// Volume of the order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> order_book;  <span style=color:#75715e>// Global vector holding the order book
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function to modify orders in the order book
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>modify_orders</span>(<span style=color:#66d9ef>int</span> thread_id) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> start_index <span style=color:#f92672>=</span> thread_id <span style=color:#f92672>*</span> (order_book.size() <span style=color:#f92672>/</span> NUM_THREADS);  <span style=color:#75715e>// Starting index for this thread&#39;s partition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> end_index   <span style=color:#f92672>=</span> start_index <span style=color:#f92672>+</span> (order_book.size() <span style=color:#f92672>/</span> NUM_THREADS);  <span style=color:#75715e>// Ending index for this thread&#39;s partition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> start_index; i <span style=color:#f92672>&lt;</span> end_index; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Simulate order cancellation/modification
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (order_book[i].volume <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>            order_book[i].volume <span style=color:#f92672>-=</span> <span style=color:#ae81ff>100</span>;  <span style=color:#75715e>// Reduce volume (partial cancellation)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span><span style=color:#f92672>&gt;</span> threads;  <span style=color:#75715e>// Vector to hold threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create and start threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NUM_THREADS; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        threads.emplace_back(modify_orders, i);  <span style=color:#75715e>// Launch threads to modify orders in parallel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for threads to complete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> t : threads) {
</span></span><span style=display:flex><span>        t.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=explanation>Explanation:
<a class=anchor href=#explanation>#</a></h4><ol><li><strong><code>OrderBookLevel</code> Structure:</strong> Represents a single order at a given price level, containing its <code>price</code> and <code>volume</code>.</li><li><strong><code>order_book</code> (Global):</strong> A vector holding all orders, with each entry representing a specific price level.</li><li><strong>Parallel Modification:</strong> The code uses multi-threading to parallelize order book modifications. Each thread processes a portion of the <code>order_book</code>, reducing order volume if it exceeds 100.</li><li><strong><code>modify_orders</code> Function:</strong> Each thread works on a segment of the order book defined by <code>start_index</code> and <code>end_index</code>. It simulates order modification by decreasing the volume (if greater than 100).</li><li><strong>Thread Management:</strong> Threads are created and joined to ensure parallel execution and completion.</li></ol><h4 id=potential-false-sharing>Potential False Sharing
<a class=anchor href=#potential-false-sharing>#</a></h4><p><strong>False sharing</strong> occurs when multiple threads modify logically independent data that happens to reside within the same cache line. This leads to unnecessary cache invalidations and reloads, significantly degrading performance.</p><p><strong>In this code:</strong></p><ul><li>The <code>order_book</code> vector is shared, and each thread modifies different <code>OrderBookLevel</code> objects.</li><li>If adjacent <code>OrderBookLevel</code> objects happen to fall on the same cache line, modifying them from different threads can trigger false sharing.</li></ul><p>For example, if <code>OrderBookLevel[i].price</code> and <code>OrderBookLevel[i+1].volume</code> reside on the same cache line, modifying them concurrently will cause cache invalidations, even though the data is logically distinct.</p><h2 id=mitigation-strategies-for-false-sharing-ordered-by-potential-efficiency><strong>Mitigation Strategies for False Sharing (Ordered by Potential Efficiency)</strong>
<a class=anchor href=#mitigation-strategies-for-false-sharing-ordered-by-potential-efficiency>#</a></h2><h3 id=1-soa-separate-arrays-optionally-grouped-in-a-struct>1. <strong>SoA: Separate Arrays (Optionally Grouped in a Struct)</strong>
<a class=anchor href=#1-soa-separate-arrays-optionally-grouped-in-a-struct>#</a></h3><p>Instead of using an Array of Structures (AoS), the key idea is to store each field (price, volume, etc.) in <em>separate arrays</em>. This organization reduces false sharing and can improve memory access patterns.</p><p><strong>Option A: Separate Arrays Only</strong></p><p>This is the simplest implementation, where you declare separate arrays for each field:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Separate arrays for prices and volumes
</span></span></span><span style=display:flex><span><span style=color:#75715e>// std::vector&lt;int&gt; prices(ORDER_BOOK_SIZE);  //Uncomment this line in main as well
</span></span></span><span style=display:flex><span><span style=color:#75715e>// std::vector&lt;int&gt; volumes(ORDER_BOOK_SIZE);  //Uncomment this line in main as well
</span></span></span></code></pre></div><p><strong>Option B: Separate Arrays Grouped in a Struct</strong></p><p>For better organization, you can group the separate arrays within a <code>struct</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Structure to hold the separate arrays
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderBook</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> prices;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> volumes;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>Advantages and Disadvantages (Concise):</strong></p><ul><li><strong>Organization:</strong> Option B (struct) provides better logical grouping of related arrays.</li><li><strong>Access:</strong> Option A (separate arrays) uses direct access; Option B (struct) accesses via struct members.</li></ul><p><strong>Complete Example Code (Option B - Separate Arrays in a Struct):</strong></p><p>The following code demonstrates how to modify volumes using <strong>Option B</strong> and addresses the issues mentioned:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> NUM_THREADS <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ORDER_BOOK_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Structure to hold the separate arrays
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderBook</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> prices;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> volumes;
</span></span><span style=display:flex><span>};  <span style=color:#75715e>// Don&#39;t forget the semicolon!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    OrderBook order_book; <span style=color:#75715e>//declare the struct so that its member can be accessed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    order_book.prices.resize(ORDER_BOOK_SIZE); <span style=color:#75715e>//initialize struct and its member
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    order_book.volumes.resize(ORDER_BOOK_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize the data (example)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ORDER_BOOK_SIZE; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        order_book.prices[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>        order_book.volumes[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span> <span style=color:#f92672>+</span> (i <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create and launch threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span><span style=color:#f92672>&gt;</span> threads;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NUM_THREADS; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        threads.emplace_back([<span style=color:#f92672>&amp;</span>, i]() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> start_index <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> (order_book.volumes.size() <span style=color:#f92672>/</span> NUM_THREADS);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> end_index <span style=color:#f92672>=</span> start_index <span style=color:#f92672>+</span> (order_book.volumes.size() <span style=color:#f92672>/</span> NUM_THREADS);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> start_index; j <span style=color:#f92672>&lt;</span> end_index; <span style=color:#f92672>++</span>j) {  <span style=color:#75715e>//Correct the loop counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (order_book.volumes[j] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>                    order_book.volumes[j] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Join the threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> t : threads) {
</span></span><span style=display:flex><span>        t.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Volumes modified successfully!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-data-alignment-with-padding>2. <strong>Data Alignment with Padding</strong>
<a class=anchor href=#2-data-alignment-with-padding>#</a></h3><p>Use <code>alignas(64)</code> to enforce cache-line alignment and add padding within the structure to prevent adjacent elements from sharing a cache line.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> CACHE_LINE_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>alignas</span>(CACHE_LINE_SIZE) OrderBookLevel {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> price;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> volume;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> padding[CACHE_LINE_SIZE <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>];  <span style=color:#75715e>// Padding to fill the cache line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p><strong>Explanation:</strong></p><ol><li><strong><code>alignas(CACHE_LINE_SIZE)</code>:</strong> Ensures the <code>OrderBookLevel</code> struct starts at a cache line boundary.</li><li><strong><code>padding</code> Member:</strong> Guarantees that each <code>OrderBookLevel</code> occupies a full cache line, preventing overlap and false sharing.</li><li><strong>Usage:</strong> For single instances of the struct, use both <code>alignas</code> and padding. For arrays, <code>alignas</code> applied to the array&rsquo;s element type is generally sufficient.</li><li><strong>Benefits:</strong> Improves memory access patterns, reduces cache invalidation, and enhances performance in multi-threaded applications.</li></ol><h3 id=3-partitioning-with-padding>3. <strong>Partitioning with Padding</strong>
<a class=anchor href=#3-partitioning-with-padding>#</a></h3><p>Divide the <code>order_book</code> into partitions, adding padding after each partition to ensure separation on cache lines. This strategy leverages <code>std::span</code> for efficient access to the partitions. The goal is to <em>isolate</em> the data accessed by each thread onto its own cache lines, preventing false sharing.</p><p><strong>Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;span&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> NUM_THREADS <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;                <span style=color:#75715e>// Number of threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ORDER_BOOK_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>;           <span style=color:#75715e>// Number of actual orders
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> CACHE_LINE_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;             <span style=color:#75715e>// Cache line size in bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ELEMENT_SIZE <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(OrderBookLevel); <span style=color:#75715e>// Size of OrderBookLevel struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> PADDING_ELEMENTS <span style=color:#f92672>=</span> CACHE_LINE_SIZE <span style=color:#f92672>/</span> ELEMENT_SIZE; <span style=color:#75715e>// Padding elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Structure representing an order book level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderBookLevel</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> price;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> volume;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Global order book with padding after each partition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> order_book(ORDER_BOOK_SIZE <span style=color:#f92672>+</span> (NUM_THREADS <span style=color:#f92672>*</span> PADDING_ELEMENTS));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function to modify orders using std::span, operating on partitioned data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>modify_orders</span>(std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> partition) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> level : partition) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (level.volume <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>            level.volume <span style=color:#f92672>-=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize order book with example data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ORDER_BOOK_SIZE; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        order_book[i].price <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>        order_book[i].volume <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span> <span style=color:#f92672>+</span> (i <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span><span style=color:#f92672>&gt;</span> threads;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> partition_size <span style=color:#f92672>=</span> ORDER_BOOK_SIZE <span style=color:#f92672>/</span> NUM_THREADS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NUM_THREADS; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> start_index <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> (partition_size <span style=color:#f92672>+</span> PADDING_ELEMENTS); <span style=color:#75715e>// Include padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> end_index <span style=color:#f92672>=</span> start_index <span style=color:#f92672>+</span> partition_size; <span style=color:#75715e>// Exclude padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a span covering only the partition, NOT the padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> partition(order_book.data() <span style=color:#f92672>+</span> start_index, partition_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        threads.emplace_back(modify_orders, partition);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> t : threads) {
</span></span><span style=display:flex><span>        t.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Order book modified successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=walkthrough-of-partitioning-logic><strong>Walkthrough of Partitioning Logic:</strong>
<a class=anchor href=#walkthrough-of-partitioning-logic>#</a></h4><p><strong>Goal:</strong> Divide the <code>order_book</code> into <code>NUM_THREADS</code> partitions. Each thread will work on its own partition. We want to ensure that the data each thread works on resides on separate cache lines to avoid false sharing.
<strong>Constants:</strong></p><ul><li><code>ORDER_BOOK_SIZE</code>: The number of <em>actual</em> <code>OrderBookLevel</code> elements we want to store.</li><li><code>CACHE_LINE_SIZE</code>: The size of a cache line on the target architecture (e.g., 64 bytes).</li><li><code>ELEMENT_SIZE</code>: The size of the <code>OrderBookLevel</code> struct in bytes.</li><li><code>PADDING_ELEMENTS</code>: The number of <code>OrderBookLevel</code> elements needed to fill a full cache line.
<strong><code>PADDING_ELEMENTS</code> Calculation:</strong></li></ul><p>This is the most important calculation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> PADDING_ELEMENTS <span style=color:#f92672>=</span> CACHE_LINE_SIZE <span style=color:#f92672>/</span> ELEMENT_SIZE;
</span></span></code></pre></div><p>This tells us how many <strong>extra</strong> <code>OrderBookLevel</code> elements we need to add as padding after each partition to ensure that the <em>next</em> partition starts on a new cache line. If a cache line is 64 bytes, and each <code>OrderBookLevel</code> element is 8 bytes (2 <code>int</code>s), then <code>PADDING_ELEMENTS</code> will be 64 / 8 = 8. So we will insert eight padding elements at the end of each partition.
<strong><code>order_book</code> Size:</strong></p><p>The total size of the <code>order_book</code> vector includes the actual order elements <strong>plus</strong> the padding:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> order_book(ORDER_BOOK_SIZE <span style=color:#f92672>+</span> (NUM_THREADS <span style=color:#f92672>*</span> PADDING_ELEMENTS));
</span></span></code></pre></div><p>So the total size is <code>ORDER_BOOK_SIZE</code> plus <code>PADDING_ELEMENTS</code> for <em>each</em> thread.</p><p><strong>Partition size:</strong></p><p>Each thread gets the same number of elements to work on this is achieved through the use of this line.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> partition_size <span style=color:#f92672>=</span> ORDER_BOOK_SIZE <span style=color:#f92672>/</span> NUM_THREADS;
</span></span></code></pre></div><p><strong><code>start_index</code> Calculation:</strong></p><p>The <code>start_index</code> determines where each thread&rsquo;s partition begins within the <code>order_book</code>. This calculation <em>includes</em> the padding from previous partitions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> start_index <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> (partition_size <span style=color:#f92672>+</span> PADDING_ELEMENTS);
</span></span></code></pre></div><p>For example: If you have three threads; the <code>start_index</code> of the partition would be the number of elements from previous partion added with padding from previous parition. If each partition is assigned <code>partion_size</code> elements and padded with <code>PADDING_ELEMENTS</code> this is the total that is mulitplied the thread number to assigned the <code>start_index</code>.
<strong><code>std::span</code> Construction:</strong></p><p>The <code>std::span</code> provides a <em>view</em> of the data within the <code>order_book</code> that a thread is allowed to access. <em>Crucially</em>, the <code>std::span</code> only covers the <em>actual</em> order elements within the partition, <em>excluding</em> the padding:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> partition(order_book.data() <span style=color:#f92672>+</span> start_index, partition_size);
</span></span></code></pre></div><p>The span starts at the correct <code>start_index</code>, but its length is only <code>partition_size</code> (the number of actual order elements). The span prevents the thread from accidentally accessing or modifying the padding.
<strong>Iteration:</strong></p><p>The <code>modify_orders</code> function uses a <code>std::span</code> to iterate only though a partion which is the <code>order_book</code> which is allocated to the current thread.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> level : partition) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (level.volume <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>        level.volume <span style=color:#f92672>-=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Example Calculation:</strong></p><p>Let&rsquo;s say:</p><ul><li><code>NUM_THREADS = 4</code></li><li><code>ORDER_BOOK_SIZE = 1000</code></li><li><code>CACHE_LINE_SIZE = 64</code> bytes</li><li><code>sizeof(OrderBookLevel) = 8</code> bytes (2 <code>int</code>s)</li></ul><p>Then:</p><ul><li><code>PADDING_ELEMENTS = 64 / 8 = 8</code></li><li>The total size of <code>order_book</code> is <code>1000 + (4 * 8) = 1032</code></li><li><code>partition_size = 1000 / 4 = 250</code></li></ul><p>For Thread 1 (<code>i = 1</code>):</p><ul><li><code>start_index = 1 * (250 + 8) = 258</code></li><li>The <code>std::span</code> for Thread 1 will start at index 258 and have a length of 250.</li><li>Thread 1 can access element from <code>order_book[258]</code> to <code>order_book[507]</code> without any risks.</li></ul><p>This detailed explanation and calculation example should make the partitioning logic much clearer to your readers.</p><h3 id=4-local-buffers-and-merging-results>4. <strong>Local Buffers and Merging Results</strong>
<a class=anchor href=#4-local-buffers-and-merging-results>#</a></h3><p>Each thread processes data in its local buffer and then merges it back into the shared data after completion. This strategy eliminates false sharing but introduces a copying overhead.</p><p><strong>Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;atomic&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> NUM_THREADS <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>// Number of threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ORDER_BOOK_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>;  <span style=color:#75715e>// Size of the order book
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Structure for representing an order book level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderBookLevel</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> price;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> volume;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Global vector to hold the order book
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> order_book(ORDER_BOOK_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function to modify orders in a local buffer, then merge them back
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>modify_orders</span>(<span style=color:#66d9ef>int</span> thread_id) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Local buffer for the thread
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>OrderBookLevel<span style=color:#f92672>&gt;</span> local_buffer(ORDER_BOOK_SIZE <span style=color:#f92672>/</span> NUM_THREADS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Determine which portion of the order book the thread is responsible for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> start_index <span style=color:#f92672>=</span> thread_id <span style=color:#f92672>*</span> (ORDER_BOOK_SIZE <span style=color:#f92672>/</span> NUM_THREADS);  <span style=color:#75715e>// Starting index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> end_index   <span style=color:#f92672>=</span> start_index <span style=color:#f92672>+</span> (ORDER_BOOK_SIZE <span style=color:#f92672>/</span> NUM_THREADS);  <span style=color:#75715e>// Ending index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Each thread processes its local buffer (work is done on the local copy)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> start_index; i <span style=color:#f92672>&lt;</span> end_index; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        local_buffer[i <span style=color:#f92672>-</span> start_index] <span style=color:#f92672>=</span> order_book[i];  <span style=color:#75715e>// Copy data to local buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Simulate order cancellation/modification
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (local_buffer[i <span style=color:#f92672>-</span> start_index].volume <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>            local_buffer[i <span style=color:#f92672>-</span> start_index].volume <span style=color:#f92672>-=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// After local processing, merge results back into the main order book
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> start_index; i <span style=color:#f92672>&lt;</span> end_index; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        order_book[i] <span style=color:#f92672>=</span> local_buffer[i <span style=color:#f92672>-</span> start_index];  <span style=color:#75715e>// Copy modified data back
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize order book
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ORDER_BOOK_SIZE; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        order_book[i].price <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>        order_book[i].volume <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span> <span style=color:#f92672>+</span> (i <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span><span style=color:#f92672>&gt;</span> threads;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create and start threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NUM_THREADS; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        threads.emplace_back(modify_orders, i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for threads to complete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> t : threads) {
</span></span><span style=display:flex><span>        t.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Order book modified successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Explanation and Considerations:</strong></p><ol><li><strong>Local Buffer:</strong> Each thread operates on a local buffer, thus avoiding direct modifications to the global <code>order_book</code>.</li><li><strong>Merging:</strong> After processing, the thread merges back the data by merging it in main <code>order_book</code></li><li><strong>Benefit:</strong> Working on local copies prevent false sharing.</li><li><strong>Limitations:</strong> This technique involves extra memory copy, which may outweigh the advantage of using multiple cores as the threads have to process the volume on their local copy. Also we cannot be sure whether this solution provides better efficiency than performing on an array on single process. It depends whether copying the data is more cheaper that overhead caused by cache invalidation due to false sharing.</li></ol><p><strong>When to Consider Local Buffers:</strong></p><ul><li><strong>Complex Processing:</strong> If the processing within the loop is very complex and computationally intensive, the overhead of copying might be small compared to the overall processing time.</li><li><strong>High Contention:</strong> When there&rsquo;s very high contention (frequent cache invalidation) due to false sharing, the local buffer approach might be beneficial.</li></ul><p><strong>Important Note:</strong></p><p>It&rsquo;s crucial to benchmark and profile your code to determine whether this approach is actually improving performance compared to other techniques or even a single-threaded solution. The optimal strategy depends on the specific workload and hardware characteristics.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#scenario-impact-of-adjacent-element-modification-during-parallel-loop-processing><strong>Scenario: Impact of Adjacent Element Modification During Parallel Loop Processing</strong></a><ul><li><a href=#false-sharing-illustration><strong>False Sharing Illustration</strong></a></li><li><a href=#code-parallel-order-book-modification-illustrating-potential-false-sharing><strong>Code: Parallel Order Book Modification (Illustrating Potential False Sharing)</strong></a></li></ul></li><li><a href=#mitigation-strategies-for-false-sharing-ordered-by-potential-efficiency><strong>Mitigation Strategies for False Sharing (Ordered by Potential Efficiency)</strong></a><ul><li><a href=#1-soa-separate-arrays-optionally-grouped-in-a-struct>1. <strong>SoA: Separate Arrays (Optionally Grouped in a Struct)</strong></a></li><li><a href=#2-data-alignment-with-padding>2. <strong>Data Alignment with Padding</strong></a></li><li><a href=#3-partitioning-with-padding>3. <strong>Partitioning with Padding</strong></a></li><li><a href=#4-local-buffers-and-merging-results>4. <strong>Local Buffers and Merging Results</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>