<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Algometix</title>
<meta name="keywords" content="">
<meta name="description" content="Title: &ldquo;An Overview of Cache Coherence Protocols in Multi-Core Architectures&rdquo;
Date: 2025-02-03T12:00:00&#43;05:30
Author: &ldquo;Pralay Patoria&rdquo;
Tags: [&ldquo;C&#43;&#43;&rdquo;, &ldquo;Performance&rdquo;, &ldquo;Cache Optimization&rdquo;, &ldquo;Multi-Core Architectures&rdquo;]
Categories: [&ldquo;Low-Latency Programming&rdquo;, &ldquo;Computer Architecture&rdquo;]
Draft: true

Introduction
Modern multi-core processors rely on private caches to reduce latency and improve performance. However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. Cache coherence guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.">
<meta name="author" content="">
<link rel="canonical" href="https://algometix.com/posts/cache_coherence_protocols/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://algometix.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://algometix.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://algometix.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://algometix.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://algometix.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://algometix.com/posts/cache_coherence_protocols/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://algometix.com/posts/cache_coherence_protocols/">
  <meta property="og:site_name" content="Algometix">
  <meta property="og:title" content="Algometix">
  <meta property="og:description" content="Title: “An Overview of Cache Coherence Protocols in Multi-Core Architectures”
Date: 2025-02-03T12:00:00&#43;05:30
Author: “Pralay Patoria”
Tags: [“C&#43;&#43;”, “Performance”, “Cache Optimization”, “Multi-Core Architectures”]
Categories: [“Low-Latency Programming”, “Computer Architecture”]
Draft: true
Introduction Modern multi-core processors rely on private caches to reduce latency and improve performance. However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. Cache coherence guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="Title: &ldquo;An Overview of Cache Coherence Protocols in Multi-Core Architectures&rdquo;
Date: 2025-02-03T12:00:00&#43;05:30
Author: &ldquo;Pralay Patoria&rdquo;
Tags: [&ldquo;C&#43;&#43;&rdquo;, &ldquo;Performance&rdquo;, &ldquo;Cache Optimization&rdquo;, &ldquo;Multi-Core Architectures&rdquo;]
Categories: [&ldquo;Low-Latency Programming&rdquo;, &ldquo;Computer Architecture&rdquo;]
Draft: true

Introduction
Modern multi-core processors rely on private caches to reduce latency and improve performance. However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. Cache coherence guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://algometix.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://algometix.com/posts/cache_coherence_protocols/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Title: \u0026ldquo;An Overview of Cache Coherence Protocols in Multi-Core Architectures\u0026rdquo;\nDate: 2025-02-03T12:00:00+05:30\nAuthor: \u0026ldquo;Pralay Patoria\u0026rdquo;\nTags: [\u0026ldquo;C++\u0026rdquo;, \u0026ldquo;Performance\u0026rdquo;, \u0026ldquo;Cache Optimization\u0026rdquo;, \u0026ldquo;Multi-Core Architectures\u0026rdquo;]\nCategories: [\u0026ldquo;Low-Latency Programming\u0026rdquo;, \u0026ldquo;Computer Architecture\u0026rdquo;]\nDraft: true\nIntroduction Modern multi-core processors rely on private caches to reduce latency and improve performance. However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. Cache coherence guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.\n",
  "keywords": [
    
  ],
  "articleBody": "Title: “An Overview of Cache Coherence Protocols in Multi-Core Architectures”\nDate: 2025-02-03T12:00:00+05:30\nAuthor: “Pralay Patoria”\nTags: [“C++”, “Performance”, “Cache Optimization”, “Multi-Core Architectures”]\nCategories: [“Low-Latency Programming”, “Computer Architecture”]\nDraft: true\nIntroduction Modern multi-core processors rely on private caches to reduce latency and improve performance. However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. Cache coherence guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.\nThis article explores why cache coherence is crucial, common problems that arise without it, and how protocols address these issues.\nWhy Are Cache Coherence Protocols Important? Cache coherence protocols ensure data consistency across multiple cores by preventing stale reads, lost updates, and synchronization failures. Here are some critical problems that arise without cache coherence:\n1. Stale Reads (Reader-Writer Inconsistency) Problem: One core writes a value while another core reads the same memory but sees an old (stale) value due to delayed cache updates. Example: A flag-based synchronization where the reader sees the flag but not the updated data. - Core 1 writes flag = true but the change is only in its private cache. - Core 2 checks flag, but it still sees the old value (false) and proceeds incorrectly. 2. Reordering in Producer-Consumer Patterns Problem: A producer writes data and then sets a flag, but the consumer sees the flag before the data update propagates. Example: A message queue where msg.ready is observed before msg.payload is updated. 3. Broken Mutual Exclusion (Locks and Mutexes Failing) Problem: A core locks a shared resource, but another core sees an outdated cached copy of the lock variable, causing multiple threads to enter a critical section. Example: A spinlock where both threads see lock = false due to stale cache. 4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers) Problem: One core modifies a pointer-based data structure while another core reads it, leading to segmentation faults or undefined behavior. Example: A linked list where a node is deleted, but another thread still has an outdated pointer. 5. Preventing Stale Data and Memory Visibility Issues Each core has a private cache to minimize access time. Without synchronization, a core might read outdated (stale) data modified by another core.\nMemory Visibility and Ordering Issues Stale Reads → A core sees an outdated value. Lost Updates → Multiple cores modify a variable, but some updates are lost. Synchronization Failures → Locks, mutexes, and atomic operations fail due to stale values. Reordering Issues → Dependent operations appear out of order. Example:\nCore 1 writes data = 42, then ready = 1, but Core 2 sees ready = 1 before data = 42, leading to incorrect execution. 6. Inconsistent Shared Data Structures Problem: Pointers or references to shared data structures become stale or inconsistent due to memory updates not propagating correctly. Example: A node is deleted from a linked list, but another core still follows a stale pointer, leading to a segmentation fault. 7. Avoiding Data Races Data races occur when multiple cores modify the same memory location simultaneously, leading to unpredictable behavior. Cache coherence protocols prevent such races by ensuring synchronized memory updates.\n8. Maintaining System Performance Cache coherence protocols balance data consistency and performance overhead by reducing unnecessary cache invalidations and updates. This helps preserve cache efficiency while ensuring correctness.\n8.1 Avoiding Frequent Cache Misses With Cache Coherence: Ensures cores can access recent updates without fetching from main memory. When a core reads a variable that was recently modified by another core, it may need to fetch the latest value from main memory (incurring a high latency). If cache coherence is absent, every read might result in a costly memory access. With Cache Coherence: Ensures cores can access recent updates without fetching from main memory. The protocol ensures that caches share the latest modified value efficiently. If a core needs data modified by another core, it can retrieve it from the other core’s cache instead of going to main memory. Performance Benefit: Reduces latency due to fewer cache misses. 8.2 Preventing Unnecessary Cache Invalidations Optimized protocols like MESI reduce excessive invalidations, maintaining efficient cache usage. Without Optimization: Naïve invalidation policies may cause frequent invalidations, forcing cores to reload data from memory unnecessarily. With Optimized Cache Coherence: Modern protocols (e.g., MESI) use state-based tracking to only invalidate lines when absolutely necessary. Performance Benefit: Avoids excessive cache flushing, leading to better cache retention and reuse. 8.3 Reducing Bus Contention in Shared-Memory Systems Without Cache Coherence: Multiple cores repeatedly fetch the same shared data from memory. This increases bus traffic, causing delays in other memory requests. With Cache Coherence: A modified cache line can be shared between cores without frequent memory access. Performance Benefit: Reduces memory bus congestion and improves overall execution speed. 8.4 Optimized Synchronization Performance Without Cache Coherence: Locks and atomic operations require costly memory barriers. With Cache Coherence: Caches maintain coherence efficiently, ensuring that locks and synchronization primitives work with minimal overhead. Performance Benefit: Faster lock acquisition and release, improving multi-threaded application performance. Example: Ensuring Correct Locking with Cache Coherence #include #include #include std::atomic\u003cint\u003e lock(0); void critical_section(int id) { while (lock.exchange(1, std::memory_order_acquire) == 1); // Critical section std::cout \u003c\u003c \"Thread \" \u003c\u003c id \u003c\u003c \" entered critical section\\n\"; lock.store(0, std::memory_order_release); } int main() { std::thread t1(critical_section, 1); std::thread t2(critical_section, 2); t1.join(); t2.join(); return 0; } This demonstrates how cache coherence ensures that all threads correctly see updates to the `lock** variable, preventing simultaneous access to the critical section.\nWithout cache coherence, Core 2 might still see lock = 0 even after Core 1 sets it to 1, leading to race conditions. Cache coherence ensures the updated value propagates correctly across cores, enabling efficient locking and synchronization.\nThe memory barriers (using memory_order_acquire and memory_order_release) ensure correct ordering of operations and enforce synchronization between cache and memory. However, cache coherence protocols play a separate but complementary role in this example.\n**Role of Memory Barriers vs. Cache Coherence in the Example** 1. **Memory Barriers (Acquire-Release Semantics)** - `memory_order_acquire` ensures that all prior writes from other threads become visible before proceeding. - `memory_order_release` ensures that all writes before releasing the lock are visible to other threads before the lock is set to 0. - This prevents instruction reordering and ensures correct synchronization. 2. **Cache Coherence Protocols (e.g., MESI)** - Even with memory barriers, cache coherence is required to ensure that updates to `lock` in **one core’s cache** are visible to other cores **without explicit memory flushes**. - If there were **no cache coherence**, Core 1 could write `lock = 1`, but Core 2 might still see `lock = 0` due to an outdated cache line. - **With cache coherence,** when Core 1 updates `lock = 1`, the protocol ensures Core 2 gets the updated value (by invalidating the stale copy or updating it directly). **What If There Was No Cache Coherence?** - Core 1 writes `lock = 1`, but Core 2 might still have a stale cached value (`lock = 0`). - This could lead to **two threads entering the critical section simultaneously**, breaking mutual exclusion. - Memory barriers alone do **not** force a cache update—they only control ordering. If there were no coherence mechanism, Core 2 would need **explicit memory flushes** (e.g., `std::atomic_thread_fence(std::memory_order_seq_cst)`) to synchronize data. **Memory Barriers vs. Cache Coherence** - **Memory barriers ensure ordering** of operations and prevent reordering. - **Cache coherence ensures visibility** of updates across cores **without explicit memory flushes**. - **Together,** they ensure correctness and improve performance by avoiding unnecessary memory operations. Conclusion Cache coherence is a fundamental concept in multi-core systems, ensuring memory consistency, preventing stale reads, and optimizing synchronization mechanisms. By maintaining a coherent view of memory across cores, cache coherence protocols significantly enhance performance, correctness, and reliability in modern parallel computing environments.\n",
  "wordCount" : "1292",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://algometix.com/posts/cache_coherence_protocols/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Algometix",
    "logo": {
      "@type": "ImageObject",
      "url": "https://algometix.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://algometix.com/" accesskey="h" title="Algometix (Alt + H)">Algometix</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://algometix.com/" title="Welcome to AlgoMetix">
                    <span>Welcome to AlgoMetix</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://algometix.com/">Home</a>&nbsp;»&nbsp;<a href="https://algometix.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">7 min

</div>
  </header> 
  <div class="post-content"><p><strong>Title</strong>: &ldquo;An Overview of Cache Coherence Protocols in Multi-Core Architectures&rdquo;<br>
<strong>Date</strong>: 2025-02-03T12:00:00+05:30<br>
<strong>Author</strong>: &ldquo;Pralay Patoria&rdquo;<br>
<strong>Tags</strong>: [&ldquo;C++&rdquo;, &ldquo;Performance&rdquo;, &ldquo;Cache Optimization&rdquo;, &ldquo;Multi-Core Architectures&rdquo;]<br>
<strong>Categories</strong>: [&ldquo;Low-Latency Programming&rdquo;, &ldquo;Computer Architecture&rdquo;]<br>
<strong>Draft</strong>: true</p>
<hr>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Modern multi-core processors rely on private caches to reduce latency and improve performance. However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. <strong>Cache coherence</strong> guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.</p>
<p>This article explores why cache coherence is crucial, common problems that arise without it, and how protocols address these issues.</p>
<h1 id="why-are-cache-coherence-protocols-important">Why Are Cache Coherence Protocols Important?<a hidden class="anchor" aria-hidden="true" href="#why-are-cache-coherence-protocols-important">#</a></h1>
<p>Cache coherence protocols ensure <strong>data consistency across multiple cores</strong> by preventing stale reads, lost updates, and synchronization failures. Here are some critical problems that arise without cache coherence:</p>
<h2 id="1-stale-reads-reader-writer-inconsistency">1. Stale Reads (Reader-Writer Inconsistency)<a hidden class="anchor" aria-hidden="true" href="#1-stale-reads-reader-writer-inconsistency">#</a></h2>
<ul>
<li><strong>Problem:</strong> One core writes a value while another core reads the same memory but sees an old (stale) value due to delayed cache updates.</li>
<li><strong>Example:</strong> A flag-based synchronization where the reader sees the flag but not the updated data.
- Core 1 writes flag = true but the change is only in its private cache.
- Core 2 checks flag, but it still sees the old value (false) and proceeds incorrectly.</li>
</ul>
<h2 id="2-reordering-in-producer-consumer-patterns">2. Reordering in Producer-Consumer Patterns<a hidden class="anchor" aria-hidden="true" href="#2-reordering-in-producer-consumer-patterns">#</a></h2>
<ul>
<li><strong>Problem:</strong> A producer writes data and then sets a flag, but the consumer sees the flag before the data update propagates.</li>
<li><strong>Example:</strong> A message queue where <code>msg.ready</code> is observed before <code>msg.payload</code> is updated.</li>
</ul>
<h2 id="3-broken-mutual-exclusion-locks-and-mutexes-failing">3. Broken Mutual Exclusion (Locks and Mutexes Failing)<a hidden class="anchor" aria-hidden="true" href="#3-broken-mutual-exclusion-locks-and-mutexes-failing">#</a></h2>
<ul>
<li><strong>Problem:</strong> A core locks a shared resource, but another core sees an outdated cached copy of the lock variable, causing multiple threads to enter a critical section.</li>
<li><strong>Example:</strong> A spinlock where both threads see <code>lock = false</code> due to stale cache.</li>
</ul>
<h2 id="4-shared-data-structure-corruption-linked-lists-trees-buffers">4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)<a hidden class="anchor" aria-hidden="true" href="#4-shared-data-structure-corruption-linked-lists-trees-buffers">#</a></h2>
<ul>
<li><strong>Problem:</strong> One core modifies a pointer-based data structure while another core reads it, leading to segmentation faults or undefined behavior.</li>
<li><strong>Example:</strong> A linked list where a node is deleted, but another thread still has an outdated pointer.</li>
</ul>
<h2 id="5-preventing-stale-data-and-memory-visibility-issues">5. Preventing Stale Data and Memory Visibility Issues<a hidden class="anchor" aria-hidden="true" href="#5-preventing-stale-data-and-memory-visibility-issues">#</a></h2>
<p>Each core has a private cache to minimize access time. Without synchronization, a core might read <strong>outdated (stale) data</strong> modified by another core.</p>
<h3 id="memory-visibility-and-ordering-issues">Memory Visibility and Ordering Issues<a hidden class="anchor" aria-hidden="true" href="#memory-visibility-and-ordering-issues">#</a></h3>
<ul>
<li><strong>Stale Reads</strong> → A core sees an outdated value.</li>
<li><strong>Lost Updates</strong> → Multiple cores modify a variable, but some updates are lost.</li>
<li><strong>Synchronization Failures</strong> → Locks, mutexes, and atomic operations fail due to stale values.</li>
<li><strong>Reordering Issues</strong> → Dependent operations appear out of order.</li>
</ul>
<p><strong>Example:</strong></p>
<ul>
<li>Core 1 writes <code>data = 42</code>, then <code>ready = 1</code>, but Core 2 sees <code>ready = 1</code> before <code>data = 42</code>, leading to incorrect execution.</li>
</ul>
<h2 id="6-inconsistent-shared-data-structures">6. Inconsistent Shared Data Structures<a hidden class="anchor" aria-hidden="true" href="#6-inconsistent-shared-data-structures">#</a></h2>
<ul>
<li><strong>Problem:</strong> Pointers or references to shared data structures become stale or inconsistent due to memory updates not propagating correctly.</li>
<li><strong>Example:</strong> A node is deleted from a linked list, but another core still follows a stale pointer, leading to a segmentation fault.</li>
</ul>
<h2 id="7-avoiding-data-races">7. Avoiding Data Races<a hidden class="anchor" aria-hidden="true" href="#7-avoiding-data-races">#</a></h2>
<p>Data races occur when multiple cores modify the same memory location simultaneously, leading to unpredictable behavior. Cache coherence protocols prevent such races by ensuring synchronized memory updates.</p>
<h2 id="8-maintaining-system-performance">8. Maintaining System Performance<a hidden class="anchor" aria-hidden="true" href="#8-maintaining-system-performance">#</a></h2>
<p>Cache coherence protocols balance <strong>data consistency</strong> and <strong>performance overhead</strong> by reducing unnecessary cache invalidations and updates. This helps preserve cache efficiency while ensuring correctness.</p>
<h3 id="81-avoiding-frequent-cache-misses">8.1 Avoiding Frequent Cache Misses<a hidden class="anchor" aria-hidden="true" href="#81-avoiding-frequent-cache-misses">#</a></h3>
<ul>
<li><strong>With Cache Coherence:</strong> Ensures cores can access recent updates without fetching from main memory.
<ul>
<li>When a core reads a variable that was recently modified by another core, it may need to fetch the latest value from main memory (incurring a high latency).</li>
<li>If cache coherence is absent, every read might result in a costly memory access.</li>
</ul>
</li>
<li><strong>With Cache Coherence:</strong> Ensures cores can access recent updates without fetching from main memory.
<ul>
<li>The protocol ensures that caches share the latest modified value efficiently.</li>
<li>If a core needs data modified by another core, it can retrieve it from the other core&rsquo;s cache instead of going to main memory.</li>
</ul>
</li>
<li><strong>Performance Benefit:</strong> Reduces latency due to fewer cache misses.</li>
</ul>
<h3 id="82-preventing-unnecessary-cache-invalidations">8.2 Preventing Unnecessary Cache Invalidations<a hidden class="anchor" aria-hidden="true" href="#82-preventing-unnecessary-cache-invalidations">#</a></h3>
<ul>
<li><strong>Optimized protocols like MESI</strong> reduce excessive invalidations, maintaining efficient cache usage.</li>
<li><strong>Without Optimization:</strong>
<ul>
<li>Naïve invalidation policies may cause frequent invalidations, forcing cores to reload data from memory unnecessarily.</li>
</ul>
</li>
<li><strong>With Optimized Cache Coherence:</strong>
<ul>
<li>Modern protocols (e.g., MESI) use state-based tracking to only invalidate lines when absolutely necessary.</li>
</ul>
</li>
<li><strong>Performance Benefit:</strong> Avoids excessive cache flushing, leading to better cache retention and reuse.</li>
</ul>
<h3 id="83-reducing-bus-contention-in-shared-memory-systems">8.3 Reducing Bus Contention in Shared-Memory Systems<a hidden class="anchor" aria-hidden="true" href="#83-reducing-bus-contention-in-shared-memory-systems">#</a></h3>
<ul>
<li><strong>Without Cache Coherence:</strong>
<ul>
<li>Multiple cores repeatedly fetch the same shared data from memory. This increases bus traffic, causing delays in other memory requests.</li>
</ul>
</li>
<li><strong>With Cache Coherence:</strong>
<ul>
<li>A modified cache line can be shared between cores without frequent memory access.</li>
</ul>
</li>
<li><strong>Performance Benefit:</strong> Reduces memory bus congestion and improves overall execution speed.</li>
</ul>
<h3 id="84-optimized-synchronization-performance">8.4 Optimized Synchronization Performance<a hidden class="anchor" aria-hidden="true" href="#84-optimized-synchronization-performance">#</a></h3>
<ul>
<li><strong>Without Cache Coherence:</strong> Locks and atomic operations require costly memory barriers.</li>
<li><strong>With Cache Coherence:</strong> Caches maintain coherence efficiently, ensuring that locks and synchronization primitives work with minimal overhead.</li>
<li><strong>Performance Benefit:</strong> Faster lock acquisition and release, improving multi-threaded application performance.</li>
</ul>
<h3 id="example-ensuring-correct-locking-with-cache-coherence"><strong>Example: Ensuring Correct Locking with Cache Coherence</strong><a hidden class="anchor" aria-hidden="true" href="#example-ensuring-correct-locking-with-cache-coherence">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lock(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">critical_section</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (lock.exchange(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>memory_order_acquire) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; entered critical section</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    lock.store(<span style="color:#ae81ff">0</span>, std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(critical_section, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(critical_section, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    t1.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This demonstrates how <strong>cache coherence ensures that all threads correctly see updates</strong> to the `lock** variable, preventing simultaneous access to the critical section.</p>
<p><strong>Without cache coherence</strong>, Core 2 might still see <code>lock = 0</code> even after Core 1 sets it to <code>1</code>, leading to race conditions.
Cache coherence ensures the updated value propagates correctly across cores, enabling efficient locking and synchronization.</p>
<p>The <strong>memory barriers</strong> (using <code>memory_order_acquire</code> and <code>memory_order_release</code>) ensure correct ordering of operations and enforce synchronization between cache and memory.
However, <strong>cache coherence protocols</strong> play a separate but complementary role in this example.</p>
<pre><code>**Role of Memory Barriers vs. Cache Coherence in the Example**
    1. **Memory Barriers (Acquire-Release Semantics)**  
       - `memory_order_acquire` ensures that all prior writes from other threads become visible before proceeding.
       - `memory_order_release` ensures that all writes before releasing the lock are visible to other threads before the lock is set to 0.
       - This prevents instruction reordering and ensures correct synchronization.

   2. **Cache Coherence Protocols (e.g., MESI)**
      - Even with memory barriers, cache coherence is required to ensure that updates to `lock` in **one core’s cache** are visible to other cores **without explicit memory flushes**.
      - If there were **no cache coherence**, Core 1 could write `lock = 1`, but Core 2 might still see `lock = 0` due to an outdated cache line.
      - **With cache coherence,** when Core 1 updates `lock = 1`, the protocol ensures Core 2 gets the updated value (by invalidating the stale copy or updating it directly).

**What If There Was No Cache Coherence?**
    - Core 1 writes `lock = 1`, but Core 2 might still have a stale cached value (`lock = 0`).
    - This could lead to **two threads entering the critical section simultaneously**, breaking mutual exclusion.
    - Memory barriers alone do **not** force a cache update—they only control ordering.
      If there were no coherence mechanism, Core 2 would need **explicit memory flushes** (e.g., `std::atomic_thread_fence(std::memory_order_seq_cst)`) to synchronize data.

**Memory Barriers vs. Cache Coherence**  
    - **Memory barriers ensure ordering** of operations and prevent reordering.
    - **Cache coherence ensures visibility** of updates across cores **without explicit memory flushes**.
    - **Together,** they ensure correctness and improve performance by avoiding unnecessary memory operations.
</code></pre>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Cache coherence is a fundamental concept in multi-core systems, ensuring <strong>memory consistency, preventing stale reads, and optimizing synchronization mechanisms</strong>. By maintaining a coherent view of memory across cores, cache coherence protocols significantly enhance <strong>performance, correctness, and reliability</strong> in modern parallel computing environments.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on x"
            href="https://x.com/intent/tweet/?text=&amp;url=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f&amp;title=&amp;summary=&amp;source=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f&title=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on whatsapp"
            href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on telegram"
            href="https://telegram.me/share/url?text=&amp;url=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=&u=https%3a%2f%2falgometix.com%2fposts%2fcache_coherence_protocols%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://algometix.com/">Algometix</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
