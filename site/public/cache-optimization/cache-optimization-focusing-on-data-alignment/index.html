<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=35405&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Optimizing cache performance by focusing on data alignment and reducing cache misses.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:35405/cache-optimization/cache-optimization-focusing-on-data-alignment/">
  <meta property="og:site_name" content="Algometix">
  <meta property="og:title" content="Cache Optimization: Focusing on Data Alignment">
  <meta property="og:description" content="Optimizing cache performance by focusing on data alignment and reducing cache misses.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cache-optimization">
    <meta property="article:published_time" content="2025-02-06T22:10:09+00:00">
    <meta property="article:modified_time" content="2025-02-06T22:10:09+00:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="Performance Optimization">
    <meta property="article:tag" content="Low-Latency Programming">
    <meta property="article:tag" content="Cache Optimization">
    <meta property="article:tag" content="High-Performance Computing">
    <meta property="article:tag" content="C&#43;&#43; Optimization">
<title>Cache Optimization: Focusing on Data Alignment | Algometix</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:35405/cache-optimization/cache-optimization-focusing-on-data-alignment/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.798f9e21f0b07d255b9e3f4a02512a3c3b42b74fe0581811f608820991706fc7.js" integrity="sha256-eY&#43;eIfCwfSVbnj9KAlEqPDtCt0/gWBgR9giCCZFwb8c=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Algometix</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Cache Optimization: Focusing on Data Alignment</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a>
      <ul>
        <li><a href="#note">Note</a></li>
      </ul>
    </li>
    <li><a href="#initial-implementation-baseline-design">Initial Implementation: Baseline Design</a>
      <ul>
        <li><a href="#analysis">Analysis</a></li>
      </ul>
    </li>
    <li><a href="#improving-memory-layout-and-alignment">Improving Memory Layout and Alignment</a>
      <ul>
        <li><a href="#reordering-fields-to-minimize-padding">Reordering Fields to Minimize Padding</a></li>
        <li><a href="#explanation">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#explicit-alignment-for-cache-line-optimization">Explicit Alignment for Cache Line Optimization</a>
      <ul>
        <li><a href="#note-1">Note</a></li>
      </ul>
    </li>
    <li><a href="#further-improvement-by-aligning-containers-to-cache-line">Further Improvement by Aligning Containers to Cache Line</a>
      <ul>
        <li><a href="#using-aligned-arrays">Using Aligned Arrays</a></li>
        <li><a href="#explanation-1">Explanation</a></li>
        <li><a href="#c-style-aligned-arrays">C-Style Aligned Arrays</a></li>
        <li><a href="#using-aligned-vectors">Using Aligned Vectors</a></li>
        <li><a href="#explanation-2">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#additional-optimizations">Additional Optimizations</a>
      <ul>
        <li><a href="#loop-unrolling">Loop Unrolling</a></li>
        <li><a href="#why-unroll-4">Why Unroll 4?</a></li>
        <li><a href="#explanation-3">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="introduction">
  Introduction
  <a class="anchor" href="#introduction">#</a>
</h2>
<p>Cache optimization is a cornerstone of high-performance computing. This article focuses on optimizing data alignment and data structures for improved cache utilization. By leveraging benchmarking results, we refine the design and implementation of a <code>MarketData</code> struct to illustrate tangible performance gains through alignment techniques.</p>
<h3 id="note">
  Note
  <a class="anchor" href="#note">#</a>
</h3>
<p>This is the first article in a series on cache optimization, concentrating on alignment. To keep things simple, we omit multicore processing issues. In such scenarios, the shared nature of L1 and L2 caches introduces complexities like false sharing, fault tolerance, and more. These will be addressed in future articles. Techniques like buffering and prefetching, while omitted here, will also be covered in subsequent discussions.</p>
<hr>
<h2 id="initial-implementation-baseline-design">
  Initial Implementation: Baseline Design
  <a class="anchor" href="#initial-implementation-baseline-design">#</a>
</h2>
<p>The initial design of the <code>MarketData</code> struct is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MarketData</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> symbol_id;  <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> price;   <span style="color:#75715e">// 8 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> volume;     <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="analysis">
  Analysis
  <a class="anchor" href="#analysis">#</a>
</h3>
<ul>
<li><strong>Field Sizes and Padding:</strong>
<ul>
<li><code>int</code> fields (<code>symbol_id</code> and <code>volume</code>) are 4 bytes each, while <code>double price</code> is 8 bytes.</li>
<li>Due to alignment rules, the compiler adds padding after <code>symbol_id</code> (4 bytes) and after <code>volume</code> (4 bytes), making the total size of the struct 24 bytes (16 bytes for fields + 8 bytes padding).</li>
</ul>
</li>
<li><strong>Cache Line Fit:</strong>
<ul>
<li>Assuming a typical cache line size of 64 bytes, each instance of <code>MarketData</code> leaves unused space in the cache line. This could lead to inefficient cache utilization when processing arrays of <code>MarketData</code>.</li>
</ul>
</li>
</ul>
<p>Letâ€™s address these inefficiencies through iterative improvements.</p>
<hr>
<h2 id="improving-memory-layout-and-alignment">
  Improving Memory Layout and Alignment
  <a class="anchor" href="#improving-memory-layout-and-alignment">#</a>
</h2>
<h3 id="reordering-fields-to-minimize-padding">
  Reordering Fields to Minimize Padding
  <a class="anchor" href="#reordering-fields-to-minimize-padding">#</a>
</h3>
<p>By rearranging fields, we can reduce the padding and optimize the memory layout.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MarketDataReordered</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> price;   <span style="color:#75715e">// 8 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> symbol_id;  <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> volume;     <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="explanation">
  Explanation
  <a class="anchor" href="#explanation">#</a>
</h3>
<ul>
<li><strong>Field Sizes and Padding:</strong>
<ul>
<li>Placing the largest field (<code>double price</code>) first eliminates the padding after <code>symbol_id</code>.</li>
<li>Total size is now 16 bytes (all fields fit contiguously without padding).</li>
</ul>
</li>
<li><strong>Cache Line Fit:</strong>
<ul>
<li>This smaller size increases the number of <code>MarketDataReordered</code> instances that fit in a single cache line, improving cache efficiency during sequential access.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="explicit-alignment-for-cache-line-optimization">
  Explicit Alignment for Cache Line Optimization
  <a class="anchor" href="#explicit-alignment-for-cache-line-optimization">#</a>
</h2>
<p>Aligning the struct to the cache line size ensures that each instance starts at a cache-line boundary, reducing cache contention in multithreaded scenarios.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">alignas</span>(<span style="color:#ae81ff">64</span>) MarketDataAligned {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> price;   <span style="color:#75715e">// 8 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> symbol_id;  <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> volume;     <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Padding: 48 bytes (added to make total size 64 bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="note-1">
  Note
  <a class="anchor" href="#note-1">#</a>
</h3>
<ul>
<li>While aligning to 64 bytes is useful in multithreaded contexts to avoid false sharing, it introduces unnecessary memory overhead for single-threaded applications. For optimal single-threaded performance, the <code>MarketDataReordered</code> struct (16 bytes) is preferred.</li>
</ul>
<hr>
<h2 id="further-improvement-by-aligning-containers-to-cache-line">
  Further Improvement by Aligning Containers to Cache Line
  <a class="anchor" href="#further-improvement-by-aligning-containers-to-cache-line">#</a>
</h2>
<p>Efficient batch processing requires that arrays or vectors of data are also cache-aligned.</p>
<h3 id="using-aligned-arrays">
  Using Aligned Arrays
  <a class="anchor" href="#using-aligned-arrays">#</a>
</h3>
<p>Aligned arrays ensure contiguous, cache-friendly storage for fixed-size data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AlignedArray</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">alignas</span>(<span style="color:#ae81ff">64</span>) std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span>T, N<span style="color:#f92672">&gt;</span> data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> AlignedMarketDataArray <span style="color:#f92672">=</span> AlignedArray<span style="color:#f92672">&lt;</span>MarketDataReordered, <span style="color:#ae81ff">1000</span><span style="color:#f92672">&gt;</span>;
</span></span></code></pre></div><h3 id="explanation-1">
  Explanation
  <a class="anchor" href="#explanation-1">#</a>
</h3>
<ul>
<li><strong>Field Sizes and Padding:</strong>
<ul>
<li>Each <code>MarketDataReordered</code> instance is 16 bytes.</li>
<li>The total size of the array is a multiple of 64 bytes, ensuring cache alignment.</li>
</ul>
</li>
<li><strong>Cache Line Fit:</strong>
<ul>
<li>Sequential processing of <code>AlignedMarketDataArray</code> leverages cache lines effectively, reducing cache misses.</li>
</ul>
</li>
</ul>
<h3 id="c-style-aligned-arrays">
  C-Style Aligned Arrays
  <a class="anchor" href="#c-style-aligned-arrays">#</a>
</h3>
<p>For applications requiring C-style arrays, similar alignment can be achieved using explicit memory alignment.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AlignedCArray</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">alignas</span>(<span style="color:#ae81ff">64</span>) MarketDataReordered data[<span style="color:#ae81ff">1000</span>];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="using-aligned-vectors">
  Using Aligned Vectors
  <a class="anchor" href="#using-aligned-vectors">#</a>
</h3>
<p>Dynamic arrays can also benefit from cache alignment by using a custom aligned allocator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t Alignment<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">aligned_allocator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> value_type <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">*</span> <span style="color:#a6e22e">allocate</span>(std<span style="color:#f92672">::</span>size_t n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (posix_memalign(<span style="color:#f92672">&amp;</span>ptr, Alignment, n <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(T)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>bad_alloc();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span>(ptr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span>(T<span style="color:#f92672">*</span> ptr, std<span style="color:#f92672">::</span>size_t) { free(ptr); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> AlignedVector <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>MarketDataReordered, aligned_allocator<span style="color:#f92672">&lt;</span>MarketDataReordered, <span style="color:#ae81ff">64</span><span style="color:#f92672">&gt;&gt;</span>;
</span></span></code></pre></div><h3 id="explanation-2">
  Explanation
  <a class="anchor" href="#explanation-2">#</a>
</h3>
<ul>
<li><strong>Dynamic Size Flexibility:</strong>
<ul>
<li>While dynamic allocation adds overhead, the aligned allocator ensures that data is cache-aligned for efficient access.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="additional-optimizations">
  Additional Optimizations
  <a class="anchor" href="#additional-optimizations">#</a>
</h2>
<h3 id="loop-unrolling">
  Loop Unrolling
  <a class="anchor" href="#loop-unrolling">#</a>
</h3>
<p>Unrolling loops reduces loop control overhead and enhances instruction-level parallelism. Additionally, it leverages cache efficiency by processing multiple elements loaded into a cache line in a single iteration.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Process</span>(AlignedMarketDataArray updates) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#pragma GCC unroll 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> update : updates.data) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Process market data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="why-unroll-4">
  Why Unroll 4?
  <a class="anchor" href="#why-unroll-4">#</a>
</h3>
<ul>
<li><strong>Cache Line Fit:</strong>
<ul>
<li>With a <code>MarketDataReordered</code> size of 16 bytes and a 64-byte cache line, four instances fit perfectly into a single cache line. Unrolling the loop by 4 ensures that all elements loaded into the cache line are processed in one iteration, maximizing cache utilization.</li>
</ul>
</li>
<li><strong>Reduced Loop Overhead:</strong>
<ul>
<li>Fewer loop control instructions are executed, improving efficiency.</li>
</ul>
</li>
<li><strong>Other Benefits:</strong>
<ul>
<li>Unrolling also allows better instruction pipelining and parallelism, enabling the CPU to execute multiple instructions simultaneously.</li>
</ul>
</li>
</ul>
<h3 id="explanation-3">
  Explanation
  <a class="anchor" href="#explanation-3">#</a>
</h3>
<ul>
<li>By unrolling the loop to match the number of elements fitting into a cache line, we align the processing logic with hardware-level optimizations. This reduces memory access latencies and maximizes throughput.</li>
</ul>
<hr>
<h2 id="conclusion">
  Conclusion
  <a class="anchor" href="#conclusion">#</a>
</h2>
<p>Through iterative optimizations, we achieved:</p>
<ol>
<li>Reduced padding by reordering fields.</li>
<li>Aligned data structures to cache line boundaries (where necessary).</li>
<li>Leveraged aligned containers for batch processing.</li>
<li>Enhanced performance with loop unrolling tailored to cache line size.</li>
</ol>
<p>Future work will explore techniques like buffering and prefetching, along with advanced considerations for multicore architectures, in subsequent articles.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a>
      <ul>
        <li><a href="#note">Note</a></li>
      </ul>
    </li>
    <li><a href="#initial-implementation-baseline-design">Initial Implementation: Baseline Design</a>
      <ul>
        <li><a href="#analysis">Analysis</a></li>
      </ul>
    </li>
    <li><a href="#improving-memory-layout-and-alignment">Improving Memory Layout and Alignment</a>
      <ul>
        <li><a href="#reordering-fields-to-minimize-padding">Reordering Fields to Minimize Padding</a></li>
        <li><a href="#explanation">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#explicit-alignment-for-cache-line-optimization">Explicit Alignment for Cache Line Optimization</a>
      <ul>
        <li><a href="#note-1">Note</a></li>
      </ul>
    </li>
    <li><a href="#further-improvement-by-aligning-containers-to-cache-line">Further Improvement by Aligning Containers to Cache Line</a>
      <ul>
        <li><a href="#using-aligned-arrays">Using Aligned Arrays</a></li>
        <li><a href="#explanation-1">Explanation</a></li>
        <li><a href="#c-style-aligned-arrays">C-Style Aligned Arrays</a></li>
        <li><a href="#using-aligned-vectors">Using Aligned Vectors</a></li>
        <li><a href="#explanation-2">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#additional-optimizations">Additional Optimizations</a>
      <ul>
        <li><a href="#loop-unrolling">Loop Unrolling</a></li>
        <li><a href="#why-unroll-4">Why Unroll 4?</a></li>
        <li><a href="#explanation-3">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












