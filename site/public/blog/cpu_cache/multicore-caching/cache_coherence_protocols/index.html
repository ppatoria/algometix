<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=46239&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Understand cache coherence, its role in multi-core systems, and how protocols like MESI, MOESI, and directory-based coherence ensure data consistency.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:46239/blog/cpu_cache/multicore-caching/cache_coherence_protocols/">
  <meta property="og:site_name" content="Algometix">
  <meta property="og:title" content="Cache Coherence and Protocols">
  <meta property="og:description" content="Understand cache coherence, its role in multi-core systems, and how protocols like MESI, MOESI, and directory-based coherence ensure data consistency.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-02-06T23:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-06T23:00:00+00:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="Performance Optimization">
    <meta property="article:tag" content="Low-Latency Programming">
    <meta property="article:tag" content="Cache Optimization">
    <meta property="article:tag" content="Multi-Core Architecture">
    <meta property="article:tag" content="Cache Coherence">
<title>Cache Coherence and Protocols | Algometix</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:46239/blog/cpu_cache/multicore-caching/cache_coherence_protocols/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.95eedfd7f5665deb4059319a3f512f01e09607482606e34b6f8b753c1525b0d1.js" integrity="sha256-le7f1/VmXetAWTGaP1EvAeCWB0gmBuNLb4t1PBUlsNE=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Algometix</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/" class="">CPU Cache: Organization, Optimization and Challenges</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/cache-optimization/" class="">Cache Optimization Techniques</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/cache-optimization/cache-optimization-focusing-on-data-alignment/" class="">Data Alignment: Enhancing Contiguous Data Processing</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/cache-optimization/cache-optimization-through-prefetching/" class="">Cache Prefetching: Enhancing Non-Contiguous Data Processing</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/" class="">Multi-Core Caching Techniques</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/cache-hierarchy/" class="">Cache Hierarchy and Sharing</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/cache_coherence_protocols/" class="active">Cache Coherence and Protocols</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/false-sharing/" class="">False Sharing</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/false-sharing/false_sharing_adjacent_variables/" class="">Impact of Adjacent Variable Modification</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/cache_coherence_protocols_deepseek/" class="">Cache Coherence Protocols Deepseek</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/multicore-caching/cache_coherence_protocols_gemini/" class="">Cache Coherence Protocols Gemini</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/singlecore-caching/cache_coherence/" class="">Cache Coherence</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/singlecore-caching/gemini_singlecore_multicore/" class="">Gemini Singlecore Multicore</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/singlecore-caching/reordeing/" class="">Reordeing</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/blog/cpu_cache/singlecore-caching/single-multi-core-deepseek/" class="">Single Multi Core Deepseek</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Cache Coherence and Protocols</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#cache-coherence-and-protocols-ensuring-data-consistency-in-multi-core-systems"><strong>Cache Coherence and Protocols: Ensuring Data Consistency in Multi-Core Systems</strong></a>
      <ul>
        <li><a href="#why-are-cache-coherence-protocols-important"><strong>Why Are Cache Coherence Protocols Important?</strong></a></li>
      </ul>
    </li>
    <li><a href="#2-reordering-in-producer-consumer-patterns">2. Reordering in Producer-Consumer Patterns</a></li>
    <li><a href="#3-broken-mutual-exclusion-locks-and-mutexes-failing">3. Broken Mutual Exclusion (Locks and Mutexes Failing)</a></li>
    <li><a href="#4-shared-data-structure-corruption-linked-lists-trees-buffers">4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)</a></li>
    <li><a href="#5-preventing-stale-data-and-memory-visibility-issues">5. Preventing Stale Data and Memory Visibility Issues</a>
      <ul>
        <li><a href="#memory-visibility-and-ordering-issues">Memory Visibility and Ordering Issues</a></li>
      </ul>
    </li>
    <li><a href="#6-inconsistent-shared-data-structures">6. Inconsistent Shared Data Structures</a></li>
    <li><a href="#7-avoiding-data-races">7. Avoiding Data Races</a></li>
    <li><a href="#8-maintaining-system-performance">8. Maintaining System Performance</a>
      <ul>
        <li><a href="#81-avoiding-frequent-cache-misses">8.1 Avoiding Frequent Cache Misses</a></li>
        <li><a href="#82-preventing-unnecessary-cache-invalidations">8.2 Preventing Unnecessary Cache Invalidations</a></li>
        <li><a href="#83-reducing-bus-contention-in-shared-memory-systems">8.3 Reducing Bus Contention in Shared-Memory Systems</a></li>
        <li><a href="#84-optimized-synchronization-performance">8.4 Optimized Synchronization Performance</a></li>
        <li><a href="#example-ensuring-correct-locking-with-cache-coherence"><strong>Example: Ensuring Correct Locking with Cache Coherence</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="cache-coherence-and-protocols-ensuring-data-consistency-in-multi-core-systems">
  <strong>Cache Coherence and Protocols: Ensuring Data Consistency in Multi-Core Systems</strong>
  <a class="anchor" href="#cache-coherence-and-protocols-ensuring-data-consistency-in-multi-core-systems">#</a>
</h2>
<p>Modern multi -  core processors rely on private caches to reduce latency and improve performance.However, when multiple cores access the same memory location, ensuring consistency across caches becomes essential. <strong>Cache coherence</strong> guarantees that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computations.</p>
<p>This article explores why cache coherence is crucial, common problems that arise without it,and how protocols address these issues.</p>
<h3 id="why-are-cache-coherence-protocols-important">
  <strong>Why Are Cache Coherence Protocols Important?</strong>
  <a class="anchor" href="#why-are-cache-coherence-protocols-important">#</a>
</h3>
<p>Cache coherence protocols ensure <strong>data consistency across multiple cores</strong> by preventing stale reads, lost updates, and synchronization failures.
Here are some critical problems that arise without cache coherence :</p>
<p>##1. Stale Reads(Reader - Writer Inconsistency) -</p>
<ul>
<li><strong>Problem :</strong> One core writes a value while another core reads the same memory but sees an old(stale) value due to delayed cache updates.</li>
<li><strong>Example:</strong> A flag-based synchronization where the reader sees the flag but not the updated data.
- Core 1 writes flag = true but the change is only in its private cache.
- Core 2 checks flag, but it still sees the old value (false) and proceeds incorrectly.</li>
</ul>
<h2 id="2-reordering-in-producer-consumer-patterns">
  2. Reordering in Producer-Consumer Patterns
  <a class="anchor" href="#2-reordering-in-producer-consumer-patterns">#</a>
</h2>
<ul>
<li><strong>Problem:</strong> A producer writes data and then sets a flag, but the consumer sees the flag before the data update propagates.</li>
<li><strong>Example:</strong> A message queue where <code>msg.ready</code> is observed before <code>msg.payload</code> is updated.</li>
</ul>
<h2 id="3-broken-mutual-exclusion-locks-and-mutexes-failing">
  3. Broken Mutual Exclusion (Locks and Mutexes Failing)
  <a class="anchor" href="#3-broken-mutual-exclusion-locks-and-mutexes-failing">#</a>
</h2>
<ul>
<li><strong>Problem:</strong> A core locks a shared resource, but another core sees an outdated cached copy of the lock variable, causing multiple threads to enter a critical section.</li>
<li><strong>Example:</strong> A spinlock where both threads see <code>lock = false</code> due to stale cache.</li>
</ul>
<h2 id="4-shared-data-structure-corruption-linked-lists-trees-buffers">
  4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)
  <a class="anchor" href="#4-shared-data-structure-corruption-linked-lists-trees-buffers">#</a>
</h2>
<ul>
<li><strong>Problem:</strong> One core modifies a pointer-based data structure while another core reads it, leading to segmentation faults or undefined behavior.</li>
<li><strong>Example:</strong> A linked list where a node is deleted, but another thread still has an outdated pointer.</li>
</ul>
<h2 id="5-preventing-stale-data-and-memory-visibility-issues">
  5. Preventing Stale Data and Memory Visibility Issues
  <a class="anchor" href="#5-preventing-stale-data-and-memory-visibility-issues">#</a>
</h2>
<p>Each core has a private cache to minimize access time. Without synchronization, a core might read <strong>outdated (stale) data</strong> modified by another core.</p>
<h3 id="memory-visibility-and-ordering-issues">
  Memory Visibility and Ordering Issues
  <a class="anchor" href="#memory-visibility-and-ordering-issues">#</a>
</h3>
<ul>
<li><strong>Stale Reads</strong> → A core sees an outdated value.</li>
<li><strong>Lost Updates</strong> → Multiple cores modify a variable, but some updates are lost.</li>
<li><strong>Synchronization Failures</strong> → Locks, mutexes, and atomic operations fail due to stale values.</li>
<li><strong>Reordering Issues</strong> → Dependent operations appear out of order.</li>
</ul>
<p><strong>Example:</strong></p>
<ul>
<li>Core 1 writes <code>data = 42</code>, then <code>ready = 1</code>, but Core 2 sees <code>ready = 1</code> before <code>data = 42</code>, leading to incorrect execution.</li>
</ul>
<h2 id="6-inconsistent-shared-data-structures">
  6. Inconsistent Shared Data Structures
  <a class="anchor" href="#6-inconsistent-shared-data-structures">#</a>
</h2>
<ul>
<li><strong>Problem:</strong> Pointers or references to shared data structures become stale or inconsistent due to memory updates not propagating correctly.</li>
<li><strong>Example:</strong> A node is deleted from a linked list, but another core still follows a stale pointer, leading to a segmentation fault.</li>
</ul>
<h2 id="7-avoiding-data-races">
  7. Avoiding Data Races
  <a class="anchor" href="#7-avoiding-data-races">#</a>
</h2>
<p>Data races occur when multiple cores modify the same memory location simultaneously, leading to unpredictable behavior. Cache coherence protocols prevent such races by ensuring synchronized memory updates.</p>
<h2 id="8-maintaining-system-performance">
  8. Maintaining System Performance
  <a class="anchor" href="#8-maintaining-system-performance">#</a>
</h2>
<p>Cache coherence protocols balance <strong>data consistency</strong> and <strong>performance overhead</strong> by reducing unnecessary cache invalidations and updates. This helps preserve cache efficiency while ensuring correctness.</p>
<h3 id="81-avoiding-frequent-cache-misses">
  8.1 Avoiding Frequent Cache Misses
  <a class="anchor" href="#81-avoiding-frequent-cache-misses">#</a>
</h3>
<ul>
<li><strong>With Cache Coherence:</strong> Ensures cores can access recent updates without fetching from main memory.
<ul>
<li>When a core reads a variable that was recently modified by another core, it may need to fetch the latest value from main memory (incurring a high latency).</li>
<li>If cache coherence is absent, every read might result in a costly memory access.</li>
</ul>
</li>
<li><strong>With Cache Coherence:</strong> Ensures cores can access recent updates without fetching from main memory.
<ul>
<li>The protocol ensures that caches share the latest modified value efficiently.</li>
<li>If a core needs data modified by another core, it can retrieve it from the other core&rsquo;s cache instead of going to main memory.</li>
</ul>
</li>
<li><strong>Performance Benefit:</strong> Reduces latency due to fewer cache misses.</li>
</ul>
<h3 id="82-preventing-unnecessary-cache-invalidations">
  8.2 Preventing Unnecessary Cache Invalidations
  <a class="anchor" href="#82-preventing-unnecessary-cache-invalidations">#</a>
</h3>
<ul>
<li><strong>Optimized protocols like MESI</strong> reduce excessive invalidations, maintaining efficient cache usage.</li>
<li><strong>Without Optimization:</strong>
<ul>
<li>Naïve invalidation policies may cause frequent invalidations, forcing cores to reload data from memory unnecessarily.</li>
</ul>
</li>
<li><strong>With Optimized Cache Coherence:</strong>
<ul>
<li>Modern protocols (e.g., MESI) use state-based tracking to only invalidate lines when absolutely necessary.</li>
</ul>
</li>
<li><strong>Performance Benefit:</strong> Avoids excessive cache flushing, leading to better cache retention and reuse.</li>
</ul>
<h3 id="83-reducing-bus-contention-in-shared-memory-systems">
  8.3 Reducing Bus Contention in Shared-Memory Systems
  <a class="anchor" href="#83-reducing-bus-contention-in-shared-memory-systems">#</a>
</h3>
<ul>
<li><strong>Without Cache Coherence:</strong>
<ul>
<li>Multiple cores repeatedly fetch the same shared data from memory. This increases bus traffic, causing delays in other memory requests.</li>
</ul>
</li>
<li><strong>With Cache Coherence:</strong>
<ul>
<li>A modified cache line can be shared between cores without frequent memory access.</li>
</ul>
</li>
<li><strong>Performance Benefit:</strong> Reduces memory bus congestion and improves overall execution speed.</li>
</ul>
<h3 id="84-optimized-synchronization-performance">
  8.4 Optimized Synchronization Performance
  <a class="anchor" href="#84-optimized-synchronization-performance">#</a>
</h3>
<ul>
<li><strong>Without Cache Coherence:</strong> Locks and atomic operations require costly memory barriers.</li>
<li><strong>With Cache Coherence:</strong> Caches maintain coherence efficiently, ensuring that locks and synchronization primitives work with minimal overhead.</li>
<li><strong>Performance Benefit:</strong> Faster lock acquisition and release, improving multi-threaded application performance.</li>
</ul>
<h3 id="example-ensuring-correct-locking-with-cache-coherence">
  <strong>Example: Ensuring Correct Locking with Cache Coherence</strong>
  <a class="anchor" href="#example-ensuring-correct-locking-with-cache-coherence">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lock(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">critical_section</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (lock.exchange(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>memory_order_acquire) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; entered critical section</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    lock.store(<span style="color:#ae81ff">0</span>, std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(critical_section, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(critical_section, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    t1.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This demonstrates how <strong>cache coherence ensures that all threads correctly see updates</strong> to the `lock** variable, preventing simultaneous access to the critical section.</p>
<p><strong>Without cache coherence</strong>, Core 2 might still see <code>lock = 0</code> even after Core 1 sets it to <code>1</code>, leading to race conditions.
Cache coherence ensures the updated value propagates correctly across cores, enabling efficient locking and synchronization.</p>
<p>The <strong>memory barriers</strong> (using <code>memory_order_acquire</code> and <code>memory_order_release</code>) ensure correct ordering of operations and enforce synchronization between cache and memory.
However, <strong>cache coherence protocols</strong> play a separate but complementary role in this example.</p>
<pre><code>**Role of Memory Barriers vs. Cache Coherence in the Example**
    1. **Memory Barriers (Acquire-Release Semantics)**  
       - `memory_order_acquire` ensures that all prior writes from other threads become visible before proceeding.
       - `memory_order_release` ensures that all writes before releasing the lock are visible to other threads before the lock is set to 0.
       - This prevents instruction reordering and ensures correct synchronization.

   2. **Cache Coherence Protocols (e.g., MESI)**
      - Even with memory barriers, cache coherence is required to ensure that updates to `lock` in **one core’s cache** are visible to other cores **without explicit memory flushes**.
      - If there were **no cache coherence**, Core 1 could write `lock = 1`, but Core 2 might still see `lock = 0` due to an outdated cache line.
      - **With cache coherence,** when Core 1 updates `lock = 1`, the protocol ensures Core 2 gets the updated value (by invalidating the stale copy or updating it directly).

**What If There Was No Cache Coherence?**
    - Core 1 writes `lock = 1`, but Core 2 might still have a stale cached value (`lock = 0`).
    - This could lead to **two threads entering the critical section simultaneously**, breaking mutual exclusion.
    - Memory barriers alone do **not** force a cache update—they only control ordering.
      If there were no coherence mechanism, Core 2 would need **explicit memory flushes** (e.g., `std::atomic_thread_fence(std::memory_order_seq_cst)`) to synchronize data.

**Memory Barriers vs. Cache Coherence**  
    - **Memory barriers ensure ordering** of operations and prevent reordering.
    - **Cache coherence ensures visibility** of updates across cores **without explicit memory flushes**.
    - **Together,** they ensure correctness and improve performance by avoiding unnecessary memory operations.
</code></pre>
<h1 id="conclusion">
  Conclusion
  <a class="anchor" href="#conclusion">#</a>
</h1>
<p>Cache coherence is a fundamental concept in multi-core systems, ensuring <strong>memory consistency, preventing stale reads, and optimizing synchronization mechanisms</strong>. By maintaining a coherent view of memory across cores, cache coherence protocols significantly enhance <strong>performance, correctness, and reliability</strong> in modern parallel computing environments.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#cache-coherence-and-protocols-ensuring-data-consistency-in-multi-core-systems"><strong>Cache Coherence and Protocols: Ensuring Data Consistency in Multi-Core Systems</strong></a>
      <ul>
        <li><a href="#why-are-cache-coherence-protocols-important"><strong>Why Are Cache Coherence Protocols Important?</strong></a></li>
      </ul>
    </li>
    <li><a href="#2-reordering-in-producer-consumer-patterns">2. Reordering in Producer-Consumer Patterns</a></li>
    <li><a href="#3-broken-mutual-exclusion-locks-and-mutexes-failing">3. Broken Mutual Exclusion (Locks and Mutexes Failing)</a></li>
    <li><a href="#4-shared-data-structure-corruption-linked-lists-trees-buffers">4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)</a></li>
    <li><a href="#5-preventing-stale-data-and-memory-visibility-issues">5. Preventing Stale Data and Memory Visibility Issues</a>
      <ul>
        <li><a href="#memory-visibility-and-ordering-issues">Memory Visibility and Ordering Issues</a></li>
      </ul>
    </li>
    <li><a href="#6-inconsistent-shared-data-structures">6. Inconsistent Shared Data Structures</a></li>
    <li><a href="#7-avoiding-data-races">7. Avoiding Data Races</a></li>
    <li><a href="#8-maintaining-system-performance">8. Maintaining System Performance</a>
      <ul>
        <li><a href="#81-avoiding-frequent-cache-misses">8.1 Avoiding Frequent Cache Misses</a></li>
        <li><a href="#82-preventing-unnecessary-cache-invalidations">8.2 Preventing Unnecessary Cache Invalidations</a></li>
        <li><a href="#83-reducing-bus-contention-in-shared-memory-systems">8.3 Reducing Bus Contention in Shared-Memory Systems</a></li>
        <li><a href="#84-optimized-synchronization-performance">8.4 Optimized Synchronization Performance</a></li>
        <li><a href="#example-ensuring-correct-locking-with-cache-coherence"><strong>Example: Ensuring Correct Locking with Cache Coherence</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












